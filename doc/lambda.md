PS: 有空了再补这个详细文档，先写这些吧。

1、lambda
因为golang获取指针比较麻烦，我也不想用unsafa，我采用生成绝对不重复的hash的方式保存lambda表。如果重复，那就再生成一个绝对不重复的hash。
所以lambda其本质就是个string字符串，完全与string字符串任何操作通用。函数概念与数据概念也就可以互相转换了。
生成的lambda其参数域，其本质实在生成的位置，而不是在调用的位置。
而且函数参数概念，其实是函数所在作用域添加了原本归属于调用位置所在作用域的参数后执行。所以我将参数传入概念交给调用者，lambda本身就不需要参数结构概念了。

2、call
假设call所在作用域为A域，假设生成lambda时所在作用域为B。lambda的调用实质上是在调用生成lambda时的状态。
调用call所做的事情其实就是：
(1)获取args所在A作用域的一组参数，以symbol的方式，写入到B作用域，提前会读取B所在作用域内的body节点，是否存在该symbol名字，如果存在报重定义错误。
(2)lambda执行B作用域的body，如果需要参数，从刚刚设置过的body里可以获取到传入的symbol参数，获取的参数的fatherNode指向的又是A作用域，所以lambda在执行的时候，又可以使用来自A作用域的参数。
